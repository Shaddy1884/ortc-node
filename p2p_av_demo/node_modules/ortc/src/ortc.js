/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 */


(function (exports, global) {
    'use strict';

    var ortc = exports;

    var plugin;
    var init;

    function isMsIE() {
        if (typeof navigator === 'undefined') {
            return false;
        }
        return !!navigator.userAgent.match(/MSIE\s\d+/);
    }

    function createPlugin(container, height, width) {
        if (plugin) {
            return;
        }

        container = container || document.getElementById('pluginholder');
        container = container || document.body;

        plugin = document.createElement('object');
        plugin.setAttribute('id', 'rtapiPlugin');

        height = height || 400;
        width = width || 400;

        plugin.setAttribute('height', height);
        plugin.setAttribute('width', width);

        if (isMsIE()) {
            // IE requires that the object be added to the DOM before
            // loading the plugin
            container.appendChild(plugin);
            plugin.setAttribute('type', 'application/x-ortcdemo');
        } else {
            plugin.setAttribute('type', 'application/x-ortcdemo');
            container.appendChild(plugin);
        }
        init = false;
    }

    function initPlugin() {
        if (init) {
            return;
        }
        try {
            plugin.initialize();
            init = true;

            plugin.addEventListener("logevent", function (e) {
                console.log('from plugin: ', e);
            }, false);
        } catch (err) {
            throw err;
        }
    }

    ortc.preinitPlugin = function (container, height, width) {
        createPlugin(container, height, width);
        initPlugin();
    }

    ortc.getPlugin = function () {
        createPlugin();
        initPlugin();
        return plugin;
    };

}('object' === typeof module ? module.exports : (this.ortc = {}), this));

(function (exports, global) {
    'use strict';

    var util = exports.util = {};

    /** 
    * not null
    */
    function nn(x) {
        if ('undefined' === typeof x || 'null' === typeof x) {
            x = '';
        }
        return x;
    }

    /**
     * Build a unique key based on a CURTC remote port dictionary
     */
    function canonicalizeRemotePort(remotePort) {
        if ((typeof remotePort !== 'object') || (remotePort === null)) {
            return '';
        }

        var keys = ['ip', 'port', 'pwd'];
        keys.push(remotePort.username ? 'username' : 'ufrag');
        return keys.map(function (key) {
            return key + ':' + nn(remotePort[key]);
        }).join(';');
    }


    /**
     * Global map of plugin id's for remote ports
     */
    var remotePortIdMap = {};

    /**
     * Given a remotePort dictionary, find or build
     * the appropriate plugin-known ID for it.
     *
     * TODO: this is leaky, we have an ever-growing list
     * of ports we ever thought of.
     *
     * remotePort -- a remote port dictionary with port, ip, ufrag, username, pwd
     * createIfMissing -- if true, we'll make one on the fly (via the plugin) as needed. Else, if it doesnt already exist, return ''.
     */
    util.getRemotePortId = function (remotePort, createIfMissing) {
        var plugin = ortc.getPlugin();

        var portKey = canonicalizeRemotePort(remotePort);
        var remoteId = null;
        if (typeof remotePortIdMap[portKey] === 'string') {
            remoteId = remotePortIdMap[portKey];
        } else if (createIfMissing) {
            remoteId = plugin.addRemoteCandidate(remotePort.ip, remotePort.port, nn(remotePort.ufrag), nn(remotePort.pwd));
            if (remoteId.length === 0) {
                // invalid return value, unable to create remote candidate?
                throw new Error("addRemoteCandidate: error adding remote candidate");
            }
            remotePortIdMap[portKey] = remoteId;
        }

        return remoteId;
    };

    util.secureRandom = function (size) {
        var plugin = ortc.getPlugin();
        return ortc.b64.Decode(plugin.secureRandom(size));
    };

    util.getCounter = function (objectBaseName, object, counterName) {
        var pluginMethodName = objectBaseName + 'GetCounter';
        var result;
        try {
            var plugin = ortc.getPlugin();
            result = plugin[pluginMethodName](object.id, counterName);
        }
        catch (err) {
            result = undefined;
        }
        if (result < 0) {
            result = undefined;
        }
        return result;
    };

    util.getCounters = function (objectBaseName, object) {
        var pluginMethodName = objectBaseName + 'GetCounters';
        var result;
        try {
            var plugin = ortc.getPlugin();
            var s = plugin[pluginMethodName](object.id);
            result = JSON.parse(s);
        } catch (err) {
            result = {};
        }
        return result;
    };

    util.generateId = function (pre) {

        var plugin = ortc.getPlugin();
        return pre + plugin.secureRandom(3);
    };

    util.getCodecs = function () {

        var plugin = ortc.getPlugin();
        var capabilities = JSON.parse(plugin.getCapabilities()).capabilities;
        var codecs = capabilities.filter(isRtp).map(processCapability);

        return codecs;
    };

    util.getRTCCapabilities = function () {

        var codecs = util.getCodecs();

        var audioCodecs = [];
        var videoCodecs = [];

        codecs.forEach(function (codec) {
            codec.params.forEach(function (param) {
                if (param.name === 'mediaType' && param.value === 'audio') {
                    audioCodecs.push(codec);
                }

                if (param.name === 'mediaType' && param.value === 'video') {
                    videoCodecs.push(codec);
                }
            });
        });

        return new ortc.RTCCapabilities(audioCodecs, videoCodecs);
    };

    util.getRTCCodec = function (name) {
        var retCodec = null;
        var codecs = util.getCodecs();

        codecs.forEach(function (codec) {
            if (codec.name === name) {
                retCodec = codec;
            }
        });

        return retCodec;
    };


    function processCapability(cap) {
        var result = new ortc.RTCCodec(cap.payloadType, cap.encodingName, cap.bitrate, 2,
            [{ name: 'ptime', value: cap.packetSize }, { name: 'silenceSuppression', value: true },
            { name: 'protocol', value: cap.protocol }, { name: 'mediaType', value: cap.mediaType },
            { name: 'fmtp', value: '' }, { name: 'codecId', value: cap.mediaId }]);

        return result;
    }

    function isRtp(cap) {
        return cap.protocol === "RTP";
    }


}('undefined' !== typeof ortc ? ortc : module.exports, this));
