/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 */
/*
[Constructor()]
interface IceAgent : EventTarget {
    readonly sequence<RealtimePort> local;
    readonly sequence<RemoteRealtimePort> remote;
    readonly RealtimeTransport? transport;
    void addRemote(RemoteRealtimePort rem);
    void start();
    void stop();
    void closeAll();
    EventHandler? onconnect;
    EventHandler? oncandidate;
    EventHandler? onerror;
    EventHandler? oninterface;
    EventHandler? oninterfacegone;
};
 */

(function (g) {
    'use strict'; /*jshint browser:true,node:true*/

    var RealtimePort = g.icejs.RealtimePort;
    var RealtimeTransport = g.icejs.RealtimeTransport;
    var RealtimePortGatherer = g.icejs.RealtimePortGatherer;
    var RealtimePortPairChecker = g.icejs.RealtimePortPairChecker;
    var RealtimePortEvent = g.icejs.RealtimePortEvent;
    var ReflexiveRealtimePort = g.icejs.ReflexiveRealtimePort;
    var NetworkInterfaceTransportBuilder = g.icejs.NetworkInterfaceTransportBuilder;

    function createControlRandom() {
        var buffer = new ArrayBuffer(8);
        var view = new Uint16Array(buffer);
        var i;
        for (i = 0; i < view.length; ++i) {
            view[i] = Math.random() * 0x10000;
        }
        return buffer;
    }

    function isDuplicateCandidate(rem, existing) {
        var rembase = rem.base || rem;
        var exbase = existing.base || existing;
        if (rembase.ip !== exbase.ip || rembase.port !== exbase.port) {
            return false;
        }
        return existing.ip === rem.ip && existing.port === rem.port && existing.ufrag === rem.ufrag && existing.pwd === rem.pwd;
    }

    function removeFromList(list, value) {
        var idx = list.indexOf(value);
        if (idx >= 0) {
            list.splice(idx, 1);
        }
        return idx;
    }

    /*
        converts transport to string appropriate for logging.
    */
    function getTransportLog(transport) {
        if (!transport) {
            return '<empty transport>'
        }

        return '<transport: ' + transport.localPort.ip + ':' + transport.localPort.port + ' - ' +
               transport.remotePort.ip + ':' + transport.remotePort.port + '>';
    }

    /*
        converts network interface transport builder to string appropriate for logging.
    */
    function getBuilderLog(builder) {
        if (!builder) {
            return '<empty builder>';
        }

        return '<builer:' + builder.networkData.ip + '>';
    }

    /**
     * Unlike a full-blown ICE Agent, this only deals with a single component.
     */

    function ParallelRealtimeTransportBuilder(options) {
        var self = this;
        var gatherer = new RealtimePortGatherer(options);
        var gatherDone = false;
        var remote = []; // the set of remote ports
        var local = [];
        var enabled = false; // whether we are running
        var controlRandom = createControlRandom();
        var controlling = false;
        var aggressiveNomination = options.nomination === 'aggressive';
        var stunServerAttributes = [];
        var interfaceTransportBuilders = [];
        var activeBuilder;
        // var multihomeErrorFired = false;

        g.EventTarget.call(this);

        if (!options || !options.transport) {
            throw new Error('options must include transport options');
        }

        function isDuplicateRemote(rem) {
            return remote.some(function (existing) {
                return isDuplicateCandidate(rem, existing);
            });
        }

        function constructConnectEvent(newBuilder) {
            var evt = new g.Event('connect');
            evt.local = newBuilder.transport.localPort;
            evt.remote = newBuilder.transport.remotePort;
            evt.transport = newBuilder.transport;
            evt.networkData = newBuilder.networkData;
            return evt;
        }

        function networkInterfaceCameOnline(e) {
            console.log('network interface came online', e.target.networkData.ip);
            var evt = new g.Event('interfaceonline');
            evt.networkData = e.target.networkData;
            self.dispatchEvent(evt);
        }

        function networkInterfaceConnected(e) {
            console.log('parallel tb connected.', getTransportLog(self.transport), getTransportLog(e.transport), 'overwrite: ', e.overwrite);

            if (self.transport === e.transport) {
                return;
            }

            if (!self.transport || e.overwrite) {
                activeBuilder = e.target;

                Object.defineReadOnlyProperty(self, 'transport', e.transport);
                self.dispatchEvent(constructConnectEvent(activeBuilder));
                console.log('network interface connected', e.networkData.ip);
            }
        }

        function networkInterfaceClosed(e) {
            var closingBuilder = e.target;
            console.log('network interface disabled', closingBuilder.networkData.ip);

            removeFromList(interfaceTransportBuilders, closingBuilder);
            Object.defineReadOnlyProperty(self, 'transport', null);

            var evt = new g.Event('interfacegone');
            evt.networkData = closingBuilder.networkData;
            self.dispatchEvent(evt);

            console.log('choosing next builder - ', 'closedbuilder: ', getBuilderLog(closingBuilder), 'activebuilder: ', getBuilderLog(activeBuilder));
            if (closingBuilder === activeBuilder) {
                if (interfaceTransportBuilders.length > 0) {
                    activeBuilder = interfaceTransportBuilders[0];

                    // if our builder in controlling role we start sending media via new transport or transport renomination.
                    // if in controlled role just wait for the action from controlling side.
                    activeBuilder.activate();
                }
                else {
                    console.log('lack of available network interfaces.. stopping.');
                    self.dispatchEvent(new g.Event('error'));
                }
            }
        }

        function findInterfaceTransportBuilder(port) {
            var builders = interfaceTransportBuilders.filter(function (builder) {
                if (port.ip === builder.networkData.ip || (port.base && port.base.ip === builder.networkData.ip)) {
                    return builder;
                }
            });

            return builders[0];
        }

        function createInterfaceTransportBuilder(port) {
            var networkData = { ip: (port.base ? port.base.ip : port.ip) };
            console.log('network interface found', networkData.ip);

            var evt = new g.Event('interface');
            evt.networkData = networkData;
            self.dispatchEvent(evt);

            var newBuilder = new NetworkInterfaceTransportBuilder(networkData, options, controlRandom, aggressiveNomination);
            interfaceTransportBuilders.push(newBuilder);
            return newBuilder;
        }

        function newLocalPort(e) {

            console.log('new local port', e.port);

            local.push(e.port);
            var builder = findInterfaceTransportBuilder(e.port);

            if (builder) {
                builder.addLocalPort(e.port);
            }
            else {
                var newBuilder = createInterfaceTransportBuilder(e.port);
                newBuilder.addEventListener('online', networkInterfaceCameOnline);
                newBuilder.addEventListener('connect', networkInterfaceConnected);
                newBuilder.addEventListener('close', networkInterfaceClosed);
                newBuilder.start();
                newBuilder.addLocalPort(e.port);
                remote.forEach(function (rem) {
                    newBuilder.addRemotePort(rem);
                });
            }

            self.dispatchEvent(new RealtimePortEvent(e.port));
        }

        gatherer.addEventListener('port', newLocalPort);

        function gathererDone(e) {
            gatherDone = true;
            var evt;
            if (gatherer.ports.length === 0) {
                evt = new g.Event('error');
                evt.reason = 'noports';
                self.dispatchEvent(evt);
            }
        }

        gatherer.addEventListener('done', gathererDone);

        function notMultihomedError(e) {
            var evt = new g.Event('error');
            evt.reason = 'notmultihomed';
            self.dispatchEvent(evt);
        }

        gatherer.addEventListener('notmultihomed', notMultihomedError);

        self.start = function () {
            enabled = true;
            gatherer.gather();
        };

        self.stop = function () {
            enabled = false;
            interfaceTransportBuilders.forEach(function (builder) {
                builder.stop();
            });
        };

        self.closeAll = function () {
            self.stop();
            gatherer.closeAll();

            interfaceTransportBuilders.forEach(function (builder) {
                builder.close();
            })
        };

        self.addRemote = function (rem) {
            console.log('new remote port', rem);
            if (!isDuplicateRemote(rem)) {
                remote.push(rem);

                interfaceTransportBuilders.forEach(function (builder) {
                    builder.addRemotePort(rem);
                });
            }
        };

        Object.defineProperty(self, 'local', {
            get: function () {
                return gatherer.ports;
            },
            enumerable: true
        });
        Object.defineProperty(self, 'remote', {
            get: function () {
                return remote;
            },
            enumerable: true
        });

        Object.defineReadOnlyProperty(self, 'transport', null);

        self.defineEventProperty('connect');
        self.defineEventProperty('error'); // happens with zero ports, or with bad transport options
        self.defineEventProperty('port');
        self.defineEventProperty('interface');
        self.defineEventProperty('interfaceonline');
        self.defineEventProperty('interfacegone');
    }

    Object.inherits(ParallelRealtimeTransportBuilder, g.EventTarget);

    g.icejs.ParallelRealtimeTransportBuilder = ParallelRealtimeTransportBuilder;

}((typeof window === 'object') ? window : global));
