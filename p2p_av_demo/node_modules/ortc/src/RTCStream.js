/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 *   
 *   This code incorporates material from the Object RTC (ORTC) API for WebRTC community group specification draft
 *   dated 2013-11-03, obtained from http://www.w3.org/community/orca/.
 */

/*
 
 WebIDL
 [Constructor, Constructor(MediaStream)]
 interface RTCStream {
                attribute MediaStream source;
                attribute DOMString   msid;
    sequence<RTCTrack> tracks ();
    void               start ();
    void               stop ();
    void               remove ();
 };

*/


'use strict';

(function () {
    var g = ('undefined' !== typeof ortc) ? ortc : window;


    var self = null;
    var tracks = [];

    function RTCStream(sourceMS) {
        self = this;

        if (!sourceMS || !(sourceMS instanceof g.MediaStream)) {
            throw new Error('Invalid MediaStream object');
        }

        var msId = sourceMS.id;
        var src = sourceMS;


        Object.defineProperty(this, 'msid', {
            get: function () {
                return msId;
            },
            set: function (value) {
                msId = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'source', {
            get: function () {
                return src;
            },
            set: function (value) {
                src = value;
            },
            enumerable: true
        });


        for (var i = 0; i < sourceMS.audioTracks.length; ++i) {
            var rtcTrack = new g.RTCTrack(sourceMS.audioTracks.item(i));
            tracks.push(rtcTrack);
        }

        for (var i = 0; i < sourceMS.videoTracks.length; ++i) {
            var rtcTrack = new g.RTCTrack(sourceMS.videoTracks.item(i));
            tracks.push(rtcTrack);
        }

        // TODO not in spec.
        Object.defineReadOnlyProperty(this, 'rtcTracks', tracks);
    }

    //
    // get sequence of contained RTCTrack instances
    //
    RTCStream.prototype.tracks = function () {
        return tracks;
    }

    //
    // Start sending the track on the wire
    //
    RTCStream.prototype.start = function () {
        tracks.forEach(function (track) {
            track.start();
        });
    }

    //
    // Stop sending the track on the wire
    //
    RTCStream.prototype.stop = function () {
        tracks.forEach(function (track) {
            track.stop();
        });
    }

    //
    // Remove this sending stream from the RTCConnection (automatically stops sending it on the wire)
    //
    RTCStream.prototype.remove = function () {
        tracks.forEach(function (track) {
            track.remove();
        });
    }


    g.RTCStream = RTCStream;

}());