/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 */
/**
 * Responsible for connecting at most one candidate per network interface to the peer.
 * For now it only use regular nomination.
 */

/*
[Constructor(NetworkData networkData, TransportOptions options, bool useAggressive)]
interface NetworkInterfaceTransportBuilder : EventTarget {
    readonly RealtimeTransport? transport;
    void start();
    void stop();
    void addRemotePort(RemoteRealtimePort rem);
    void addLocalPort(LocalRealtimePort rem);
    EventHandler? onconnect;
    EventHandler? onerror;
    EventHandler> onclose;
};
 */

(function (g) {
    'use strict'; /*jshint browser:true,node:true*/

    var RealtimePort = g.icejs.RealtimePort;
    var RealtimeTransport = g.icejs.RealtimeTransport;
    var RealtimePortPairChecker = g.icejs.RealtimePortPairChecker;

    function createControlRandom() {
        var buffer = new ArrayBuffer(8);
        var view = new Uint16Array(buffer);
        var i;
        for (i = 0; i < view.length; ++i) {
            view[i] = Math.random() * 0x10000;
        }
        return buffer;
    }

    function buildCheckerMatcher(loc, rem) {
        return function (checker) {
            if (checker.local !== loc) {
                return false;
            }
            return checker.remote.ip === rem.ip && checker.remote.port === rem.port && checker.remote.ufrag === rem.ufrag;
        };
    }

    function removeFromList(list, value) {
        var idx = list.indexOf(value);
        if (idx >= 0) {
            list.splice(idx, 1);
        }
        return idx;
    }

    /*
        converts transport to string appropriate for logging.
    */
    function getTransportLog(transport) {
        if (!transport) {
            return 'invalid transport';
        }

        return '<transport: ' + transport.localPort.ip + ':' + transport.localPort.port + ' - ' +
               transport.remotePort.ip + ':' + transport.remotePort.port + '>';
    }

    /*
        converts checker to string appropriate for logging.
    */
    function getCheckerLog(checker) {
        if (!checker) {
            return 'invalid checker';
        }

        return '<checker: ' + checker.local.ip + ':' + checker.local.port + ' - ' +
                checker.remote.ip + ':' + checker.remote.port + '>';
    }

    function getPortLog(port) {
        if (!port) {
            return 'invalid port';
        }

        return '<port: ' + port.ip + ':' + port.port + '>';
    }

    function NetworkInterfaceTransportBuilder(networkData, options, parentsControlRandom, useAggressive) {
        var self = this;
        var aggressiveNomination = false;
        var controlling = false;
        var enabled = false;
        var nominating = false;
        var checkers = [];
        var localPorts = [];
        var remotePorts = [];
        var earlyNominees = [];
        var goodPairs = [];
        var stunServerAttributes = [];
        var transports = [];
        var controlRandom = parentsControlRandom;
        var nominatedCandidate = false;
        var lastRemoteCheckMap = {}; // contains transport ids as keys and time of the last remote check as value.
        var transportValidityPeriod = 5999;
        var interfaceOnline = false;

        aggressiveNomination = !!useAggressive;

        g.EventTarget.call(this);

        Object.defineReadOnlyProperty(self, 'networkData', networkData);

        /** 
         * Every port that we control is expected to return a coherent set of attributes.
         * This builds that set.
         */

        function buildStunServerAttributes() {
            var controlAttrType = 0x8029;
            stunServerAttributes.splice(0);
            // TODO set PRIORITY attribute
            if (controlling) {
                controlAttrType = 0x802a;
            } else {
                stunServerAttributes.push({
                    type: 0x0025
                }); // echo USE-CANDIDATE
            }
            stunServerAttributes.push({
                type: controlAttrType,
                value: controlRandom
            });
        }

        buildStunServerAttributes();

        function setStunServerAttributes(localPort) {
            localPort.setServerAttributes(stunServerAttributes);
        }

        function setCheckerControlling(checker) {
            checker.setControllerState(controlling);
        }

        function setCheckerControlRandom(checker) {
            checker.setControlRandom(controlRandom);
        }

        function findTransportByPair(loc, rem) {
            var filtered = transports.filter(function (transport) {
                if (transport.localPort === loc &&
                    transport.remotePort.ip === rem.ip &&
                    transport.remotePort.port === rem.port) {
                    return transport;
                }
            });

            return filtered[0];
        }

        function findPairByTransport(transport) {
            var filtered = checkers.filter(function (pair) {
                if (pair.local === transport.localPort &&
                    pair.remote.ip === transport.remotePort.ip &&
                    pair.remote.port === transport.remotePort.port) {
                    return pair;
                }
            });

            return filtered[0];
        }

        function fireOnConnectEvent(newTransport, overwrite) {
            console.log('trying to fire connect event for ', getTransportLog(newTransport), 'current one ', getTransportLog(self.transport));

            if (!self.transport || overwrite) {
                Object.defineReadOnlyProperty(self, 'transport', newTransport);

                var evt = new g.Event('connect');
                evt.overwrite = overwrite;
                evt.local = newTransport.localPort;
                evt.remote = newTransport.remotePort;
                evt.transport = newTransport;
                evt.networkData = networkData;
                self.dispatchEvent(evt);
            }
        }

        function updateControlling(checker, isController) {
            if (typeof isController === 'undefined') {
                controlRandom = createControlRandom();
                checkers.forEach(setCheckerControlRandom);
                // reset the tie breaker number
                // this might happen a number of times, but that's OK, it only affects new checks
                checker.check(); // force a re-check on the affected checker
            } else if (isController !== controlling) {
                // step up into the controlling role (or down from it, which should never happen)
                controlling = isController;
                buildStunServerAttributes();
                localPorts.forEach(setStunServerAttributes);
                checkers.forEach(setCheckerControlling);
            }
        }

        function unknownSsrcListener(e) {
            console.log('unknown packet arrived on', getTransportLog(e.target));
            fireOnConnectEvent(e.target, true);
        }

        function transportClosed(e) {
            console.log('closed ', getTransportLog(e.target));
            delete lastRemoteCheckMap[e.target.id];
        }

        /*
            Performs keep alive checks to quickly find out whether transport went off.
        */
        function startKeepAliveChecks(transport, checker) {
            console.log('starting keepalive check', getTransportLog(transport), getCheckerLog(checker));

            if (!checker || !transport) {
                return;
            }

            if (checker.isNominational()) {
                checker.removeCheckAttribute({ type: 0x0025 });
            }

            try {
                checker.check(function (success) {
                    if (success) {
                        console.log('good keepalive check for ' + getTransportLog(transport), getCheckerLog(checker));
                        setTimeout(function () {
                            startKeepAliveChecks(transport, checker);
                        }, 2000);
                    }
                    else {
                        console.log('bad keepalive check for ' + getTransportLog(transport), getCheckerLog(checker));
                        removeFromList(transports, transport);
                        removeFromList(checkers, checker);
                        removeFromList(goodPairs, checker);
                        delete lastRemoteCheckMap[transport.id];
                        deactivateTransport(transport);
                    }
                });
            }
            catch (ex) {
                // check if it is 'check in progress' error
                setTimeout(function () {
                    startKeepAliveChecks(transport, checker);
                }, 2000);
            }
        }

        function transportCreated(err, transport, overwrite) {
            if (err) {
                throw 'Transport wasnt created';
            }

            lastRemoteCheckMap[transport.id] = new Date();

            transports.push(transport);
            transport.addEventListener('unknownssrc', unknownSsrcListener);
            transport.addEventListener('close', transportClosed);

            startKeepAliveChecks(transport, findPairByTransport(transport));
            fireOnConnectEvent(transport, overwrite);
        }

        function createTransport(checker, overwrite) {
            var foundTransport = findTransportByPair(checker.local, checker.remote);

            if (foundTransport) {
                fireOnConnectEvent(foundTransport, overwrite);
            }
            else {
                console.log('create transport for ', getCheckerLog(checker));
                try {
                    RealtimeTransport.createTransport(checker.local, checker.remote, options.transport,
                        function (err, transport) {
                            transportCreated(err, transport, overwrite);
                        });
                } catch (ex) {
                    var evt = new g.Event('error');
                    evt.exception = ex;
                    self.dispatchEvent(evt);
                }
            }
        }

        /*
            performs ordinary checks to find whether network interface is still online.
        */
        function checkIsOnline() {
            console.log('started verifying whether network interface ' + self.networkData.ip + ' is online.');

            goodPairs.forEach(function (checker) {
                console.log('performing online check', getCheckerLog(checker));
                checker.check(function (success, isContoller) {
                    if (!success) {
                        console.log('bad online check', getCheckerLog(checker));
                        removeFromList(goodPairs, checker);
                        removeFromList(checkers, checker);
                        if (!goodPairs.length) {
                            self.dispatchEvent(new g.Event('close'));
                        }
                    }
                    else {
                        console.log('good online check', getCheckerLog(checker));
                    }
                });
            });
        }

        /*
            Deactivates transport and checks whether network interface is still online.
            If it's offline (no transports and no good pairs) it causes 'close' event.
        */
        function deactivateTransport(transport) {
            console.log('deactivating', getTransportLog(transport));
            console.log('checking online - ', 'self.transport: ', getTransportLog(self.transport), 'controlling: ', controlling, 'transportNumber: ', transports.length, (transports.length ? getTransportLog(transports[0]) : ''), 'goodPairsNumber: ', goodPairs.length, (goodPairs.length ? getCheckerLog(goodPairs[0]) : ''));

            if (transports.length === 0 &&
                goodPairs.length === 0) {
                // no valid pairs for communication... closing builder.
                self.dispatchEvent(new g.Event('close'));
                return;
            }

            if (transport === self.transport) {
                Object.defineReadOnlyProperty(self, 'transport', null);

                if (controlling) {
                    if (transports.length > 0) {
                        fireOnConnectEvent(transports[0]);
                    }
                    else if (goodPairs.length > 0) {
                        nominatedCandidate = false;
                        startNomination();
                    }
                }
            }

            if (!controlling && transports.length === 0) {
                checkIsOnline();
            }
        }

        function remoteCheckListener(e) {
            var checkedTransport = findTransportByPair(e.target, e.remote);

            if (checkedTransport) {
                lastRemoteCheckMap[checkedTransport.id] = new Date();
            }

            var useCandidate = e.request.getStunAttribute(0x0025);
            if (useCandidate && !controlling) {
                console.log('remote nomination', getPortLog(e.target), getPortLog(e.remote));
                var matcher = buildCheckerMatcher(e.target, e.remote);
                var pair = checkers.filter(matcher)[0];
                if (pair) {
                    createTransport(pair, true);
                } else {
                    // we save the nomination for when we receive signaling for the pair
                    // this happens when we send our ports out but the remote peer jumps in and nominates faster
                    // than their signaling can arrive
                    console.log('early nominee');
                    earlyNominees.push(matcher);
                }
            } // if we are controlling, ignore nominations
        }

        function addPair(loc, rem) {
            var checker = new RealtimePortPairChecker(loc, rem, controlRandom, options);
            console.log('matched port pair', loc, rem);

            checkers.push(checker);

            if (enabled) {
                sendCheck(checker);
                if (!controlling && earlyNominees.some(function (nominee) {
                    return nominee(checker);
                })) {
                    console.log('acting on early nomination');
                    createTransport(checker, true);
                }
            }
        }

        function addUseCandidateAttribute(checker) {
            if (!checker.isNominational()) {
                checker.addCheckAttribute({ type: 0x0025, value: new ArrayBuffer(0) });
            }

            return checker;
        }

        /*
            Starts performing nomination checks.
            Fires close event in case when no good pairs remaining.
        */
        function startNomination() {
            if (!nominatedCandidate && !nominating && controlling) {
                nominating = true;

                if (goodPairs.length > 0) {
                    var checker = goodPairs[0];

                    checker = addUseCandidateAttribute(checker);

                    console.log('starting nomination check', getCheckerLog(checker));
                    checker.check(function (success, isController) {
                        nominating = false;
                        if (success) {
                            console.log('good nomination check from ', getCheckerLog(checker));
                            if (!nominatedCandidate) {
                                nominatedCandidate = true;
                                createTransport(checker);
                            }
                        }
                        else {
                            console.log('bad nomination check from ', getCheckerLog(checker));
                            goodPairs.splice(0, 1);
                            startNomination();
                        }
                    });
                }
                else {
                    // no valid pairs... closing builder.
                    self.dispatchEvent(new g.Event('close'));
                }
            }
        }

        function sendCheck(checker) {
            console.log('starting ordinary check', getCheckerLog(checker));
            checker.check(function (success, isController) {
                if (success) {
                    console.log('good ordinary check', getCheckerLog(checker));
                    if (!interfaceOnline) {
                        interfaceOnline = true;
                        self.dispatchEvent(new g.Event('online'));
                    }

                    goodPairs.push(checker);

                    updateControlling(checker, isController);

                    if (controlling) {
                        console.log('successful ordinary check from ' + checker.local.ip + ' to ' + checker.remote.ip);
                        startNomination();
                    }
                }
                else {
                    console.log('bad ordinary check', getCheckerLog(checker));
                }
            });
        }

        self.start = function () {
            enabled = true;
            checkers.forEach(function (checker) {
                sendCheck(checker);
            });
        };

        self.stop = function () {
            enabled = false;
            checkers.forEach(function (checker) {
                checker.stop();
            });
        };

        self.close = function () {
          
        }

        self.addLocalPort = function (localPort) {
            localPorts.push(localPort);
            setStunServerAttributes(localPort);
            localPort.addEventListener('remotecheck', remoteCheckListener);

            remotePorts.forEach(function (port) {
                addPair(localPort, port);
            });
        };

        self.addRemotePort = function (remotePort) {
            remotePorts.push(remotePort);

            localPorts.forEach(function (port) {
                addPair(port, remotePort);
            });
        };

        /*
            Activates current interface builder (make it pop up its current transport or create it if builder doesn't have it)
        */
        self.activate = function () {
            if (controlling) {
                if (self.transport) {
                    fireOnConnectEvent(self.transport, true);
                }
                else if (transports.length > 0) {
                    fireOnConnectEvent(transports[0], true);
                }
                else {
                    // no valid transports... closing builder.
                    self.dispatchEvent(new g.Event('close'));
                }
            }
        };

        self.defineEventProperty('online');
        self.defineEventProperty('connect');
        self.defineEventProperty('close');
    }

    Object.inherits(NetworkInterfaceTransportBuilder, g.EventTarget);

    g.icejs.NetworkInterfaceTransportBuilder = NetworkInterfaceTransportBuilder;

}((typeof window === 'object') ? window : global));
