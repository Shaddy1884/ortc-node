/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 *   
 *   This code incorporates material from the Object RTC (ORTC) API for WebRTC community group specification draft
 *   dated 2013-11-03, obtained from http://www.w3.org/community/orca/.
 */

/*

WebIDL[Constructor(RTCConnectionOptions options)]
interface RTCConnection : EventTarget {
    readonly    attribute RTCSocket>         socket;
    readonly    attribute RTCConnectionState state;
    readonly    attribute RTCConnectionInfo  local;
                attribute RTCConnectionRole  role;
                attribute RTCConnectionInfo  remote;

    void                      addRemoteCandidate (RTCCandidateDescription candidate);
    void                      connect ();
    void                      gather ();
    (RTCSTream? or RTCTrack?) send ((MediaStream or MediaStreamTrack or RTCTrack or RTCStream) streamOrTrack);
    (RTCStream? or RTCTrack?) receive ((RTCStream or RTCTrack) streamOrTrack);
    sequence<RTCStream>       sendStreams ();
    sequence<RTCTrack>        sendTracks ();
    sequence<RTCStream>       receiveStreams ();
    sequence<RTCTrack>        receiveTracks ();
    void                      close ();
                
                attribute EventHandler       oncandidate;
                attribute EventHandler       onendofcandidates;
                attribute EventHandler       onactivecandidate;
                attribute EventHandler       onstatechanged;
                attribute EventHandler       onnetworkchange;
                attribute EventHandler       onunknowntrack;
 };

*/


'use strict';

(function () {

    var g = ('undefined' !== typeof ortc) ? ortc : window;


    var self = null;
    var options = null;
    var transport = null;
    var transportBuilder = null;

    var sendingTracks = [];
    var receivingTracks = [];
    var sendingStreams = [];
    var receivingStreams = [];


    function RTCConnection(opts) {
        EventTarget.call(this);

        self = this;
        options = opts;

        var remote = new g.RTCConnectionInfo(new g.RTCIceConnectionInfo());
        var role = g.RTCConnectionRole.CONTROLLING;


        Object.defineReadOnlyProperty(this, 'socket', new g.RTCSocket());
        Object.defineReadOnlyProperty(this, 'state', g.RTCConnectionState.NEW);
        Object.defineReadOnlyProperty(this, 'local', new g.RTCConnectionInfo(new g.RTCIceConnectionInfo(gatewayClient.localConfig.port.ufrag, gatewayClient.localConfig.port.pwd), new g.RTCDtlsConnectionInfo()));

        Object.defineProperty(this, 'remote', {
            get: function () {
                return remote;
            },
            set: function (value) {
                remote = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'role', {
            get: function () {
                return role;
            },
            set: function (value) {
                role = value;
                Object.defineReadOnlyProperty(this, 'role', role);
            },
            enumerable: true
        });


        this.defineEventProperty('candidate');
        this.defineEventProperty('endofcandidates');
        this.defineEventProperty('activecandidate');
        this.defineEventProperty('statechanged');
        this.defineEventProperty('networkchange');
        this.defineEventProperty('unknowntrack');

        startICEGathering();
    }

    Object.inherits(RTCConnection, EventTarget);


    //
    // set remote ICE candidate
    //
    RTCConnection.prototype.addRemoteCandidate = function (candidate) {

        if (transportBuilder) {
            transportBuilder.addRemote({
                ip: candidate.connectionAddress,
                port: candidate.connectionPort,
                ufrag: candidate.foundation,
                pwd: candidate.priority
            });
        }
    };

    //
    // connect to remote peer
    //
    RTCConnection.prototype.connect = function () {

        if (!this.remote || !this.remote.ice.usernameFrag || !this.remote.ice.password) {
            throw new Error('Connection data for the remote side missing.');
        }

        establishConnection();
    };

    //
    // usually to be called upon network changes
    //
    RTCConnection.prototype.gather = function () {
        startICEGathering();
    };

    //
    // Starts sending a MediaStream or MediaStreamTrack
    //
    RTCConnection.prototype.send = function (streamOrTrack) {

        if (streamOrTrack instanceof g.MediaStream) {
            var stream = new g.RTCStream(streamOrTrack);
            sendingStreams.push(stream);

            var tracks = stream.tracks();
            tracks.forEach(function (track) {
                sendingTracks.push(track);
            });

            return stream;
        }

        if (streamOrTrack instanceof g.MediaStreamTrack) {
            var track = new g.RTCTrack(streamOrTrack);
            sendingTracks.push(track);
            return track;
        }

        if (streamOrTrack instanceof g.RTCStream) {
            sendingStreams.push(streamOrTrack);

            var tracks = streamOrTrack.tracks();
            tracks.forEach(function (track) {
                sendingTracks.push(track);
            });
            return streamOrTrack;
        }

        if (streamOrTrack instanceof g.RTCTrack) {
            sendingTracks.push(streamOrTrack);
            return streamOrTrack;
        }
    };

    //
    // Tell the RTCConnection to expect to start receiving a RTCStream or RTCTrack from the remote peer
    //
    RTCConnection.prototype.receive = function (streamOrTrack) {

        var msStream = new g.MediaStream(streamOrTrack.msid);

        if (streamOrTrack.rtcTracks) {

            streamOrTrack.rtcTracks.forEach(function (track) {

                if (track.kind === 'audio') {
                    var audDevId = g.util.getDevice(true, false);
                    var audTrack = new g.MediaStreamTrack(audDevId);
                    audTrack.ssrc = track.ssrc;
                    msStream.audioTracks.add(audTrack);
                }

                if (track.kind === 'video') {
                    var vdoDevId = g.util.getDevice(false, false);
                    var vdoTrack = new g.MediaStreamTrack(vdoDevId);
                    vdoTrack.ssrc = track.ssrc;
                    msStream.videoTracks.add(vdoTrack);
                }
            });

            var rtcStream = new g.RTCStream(msStream);
            var tracks = rtcStream.tracks();

            tracks.forEach(function (track) {
                receivingTracks.push(track);
            });

            receivingStreams.push(rtcStream);
            return rtcStream;
        }
        else {
            var audDevId = g.util.getDevice(true, false);
            var audTrack = new g.MediaStreamTrack(audDevId);
            var audRTCTrack = new g.RTCStreamTrack(audTrack, streamOrTrack.ssrc, streamOrTrack.mediaAttributes, streamOrTrack.rtpExtHeaders);

            receivingTracks.push(audRTCTrack);
            return audRTCTrack;
        }

        if (streamOrTrack.kind && streamOrTrack.kind === 'video') {
            var vdoDevId = g.util.getDevice(false, false);
            var vdoTrack = new g.MediaStreamTrack(vdoDevId);
            var vdoRTCTrack = new g.RTCStreamTrack(vdoTrack, streamOrTrack.ssrc, streamOrTrack.mediaAttributes, streamOrTrack.rtpExtHeaders);

            receivingTracks.push(vdoRTCTrack);
            return vdoRTCTrack;
        }
    };

    //
    // Get sequence of RTCStream instances being sent over the RTCConnection
    //
    RTCConnection.prototype.sendStreams = function () {
        return sendingStreams;
    };

    //
    // Get sequence of RTCTrack instances being sent over the RTCConnection
    //
    RTCConnection.prototype.sendTracks = function () {
        return sendingTracks;
    };

    //
    // Get sequence of RTCStream instances being received
    //
    RTCConnection.prototype.receiveStreams = function () {
        return receivingStreams;
    };

    //
    // Get sequence of RTCTrack instances being received
    //
    RTCConnection.prototype.receiveTracks = function () {
        return receivingTracks;
    };

    //
    // Closes the connection
    //
    RTCConnection.prototype.close = function () {

        Object.defineReadOnlyProperty(this, 'state', g.RTCConnectionState.CLOSED);

    };

    // dispatch events
    function dispatchEvent(type, value) {
        var evt = new Event(type);

        switch (type) {

            case 'activecandidate':
                evt.localCandidate = value.local;
                evt.remoteCandidate = value.remote;
                break;

            case 'candidate':
                evt.candidate = value;
                break;

            case 'endofcandidates':
                break;

            case 'networkchange':
                break;

            case 'statechanged':
                evt.state = value;
                break;

            case 'unknowntrack':
                evt.rtpExtHeaders = value;
                break;
        }

        self.dispatchEvent(evt);
    }

    // search for given RTCStream
    function getRemoteRTCStream(id) {

        receivingStreams.forEach(function (stream) {
            if (stream.msid === id) {
                return stream;
            }
        });
    }

    // begin ICE candidate gathering
    function startICEGathering() {
        var trOptions = {
            transport: {
                mode: 'srtp',
                outboundSdes: gatewayClient.localConfig.sdes,
                inboundSdes: gatewayClient.remoteConfig.sdes
            },
            stun: {
                ip: options.iceServers[0].url.split(':')[1],    //'168.61.2.180',
                port: Number(options.iceServers[0].url.split(':')[2])   //8888
            }
        };

        transportBuilder = new RealtimeTransportBuilder(trOptions);
        transportBuilder.addEventListener('connect', gotConnection);
        transportBuilder.addEventListener('port', gotCandidate);
        transportBuilder.addEventListener('error', gotConnectionError);
        transportBuilder.start();

        Object.defineReadOnlyProperty(self, 'state', g.RTCConnectionState.SEARCHING);
        dispatchEvent('statechanged', self.state);

    }

    // establish connection between peers.
    function establishConnection() {

        if (transport && sendingTracks.length > 0 && receivingTracks.length > 0) {

            sendingTracks.forEach(function (track) {
                if (!track.source.transport) {
                    track.source.transport = transport;
                }

                track.start();
            });

            receivingTracks.forEach(function (track) {
                if (!track.source.transport) {
                    track.source.transport = transport;
                }

                track.start();
            });
        }
    }

    // remote track ready for streaming notification
    function remoteTrackReady(e) {

        var unc = true;

        receivingTracks.forEach(function (track) {
            if (track.ssrc === e.ssrc) {
                unc = false;
            }
        });

        sendingTracks.forEach(function (track) {
            if (track.ssrc === e.ssrc) {
                unc = false;
            }
        });

        establishConnection();

        if (unc) {
            dispatchEvent('unknowntrack', e.ssrc);
        }
    }

    // connection transport established notification
    function gotConnection(e) {
        console.log('got transport');

        dispatchEvent('endofcandidates');

        transport = e.transport;
        transport.addEventListener('unknownssrc', remoteTrackReady);

        var localCand = new g.RTCIceCandidateInfo(e.local.ufrag, '', 'udp', e.local.pwd, e.local.ip, e.local.port, e.local.type, '', '');
        var remoteCand = new g.RTCIceCandidateInfo(e.remote.ufrag, '', 'udp', e.remote.pwd, e.remote.ip, e.remote.port, e.remote.type, '', '');
        dispatchEvent('activecandidate', { local: localCand, remote: remoteCand });

        establishConnection();

        Object.defineReadOnlyProperty(self, 'state', g.RTCConnectionState.CONNECTED);
        dispatchEvent('statechanged', self.state);
    }

    // on connection error
    function gotConnectionError(e) {
        console.log('got transport error');

        Object.defineReadOnlyProperty(self, 'state', g.RTCConnectionState.HALTED);
        dispatchEvent('statechanged', self.state);
    }

    // got local ice candidate
    function gotCandidate(e) {
        console.log('got port');

        var cand = new g.RTCIceCandidateInfo(e.port.ufrag, '', 'udp', e.port.pwd, e.port.ip, e.port.port, e.port.type, '', '');
        dispatchEvent('candidate', cand);
    }


    g.RTCConnection = RTCConnection;

}());
