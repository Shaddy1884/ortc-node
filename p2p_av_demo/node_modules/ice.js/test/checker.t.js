'use strict'; /*jshint node:true*/
/*global ArrayBuffer,Uint8Array*/
var icejs = require('../lib/index');
var RealtimePortPairChecker = icejs.RealtimePortPairChecker;
var Event = global.Event;
var EventTarget = global.EventTarget;
var Gently = require('gently');
var gently = new Gently();

// fixture
var local;
var remote;
var response;
var timerManager;
var checker;
var localControlRandom;
var remoteControlRandom;
var localController;
var remoteController;
var extraAttribute;

// only operate on the third byte, arbitrarily

function tweakControlRandom(buffer, value) {
    var view = new Uint8Array(buffer);
    view[2] = value;
}

exports.setUp = function(cb) {
    local = new EventTarget();
    local.open = true;
    remote = new EventTarget();
    remote.ip = 'IP';
    remote.port = 1337;
    response = {};
    localControlRandom = new ArrayBuffer(8);
    tweakControlRandom(localControlRandom, 2); // low = not controller
    remoteControlRandom = new ArrayBuffer(8);
    tweakControlRandom(remoteControlRandom, 3); // high = controller
    timerManager = {};
    extraAttribute = null;
    cb();
};

function getOptions() {
    var options = {
        controlling: localController,
        roundTrip: 100,
        timerManager: timerManager,
        maxChecks: 3
    };
    if (extraAttribute) {
        options.attributes = [extraAttribute];
    }
    return options;
}

function checkAttributes(test, attrs) {
    if (extraAttribute) {
        test.strictEqual(attrs.length, 2, 'two attributes present');
    } else {
        test.strictEqual(attrs.length, 1, 'exactly one STUN attribute');
    }
    test.strictEqual(attrs[0].type, localController ? 0x802A : 0x8029);
    test.strictEqual(attrs[0].value, localControlRandom);
    if (extraAttribute) {
        test.strictEqual(attrs[1].type, extraAttribute.type, 'type matches on extra');
        test.strictEqual(attrs[1].value, extraAttribute.value, 'value matches on extra');
    }
}

function buildRemoteControllerAttribute() {
    var attr = {};
    var view;
    attr.type = remoteController ? 0x802A : 0x8029;
    attr.value = remoteControlRandom;
    return attr;
}

function expectCheck(test, succeed) {
    gently.expect(local, 'check', function(rem, attrs) {
        var cse = new Event('checksent');
        cse.remote = remote;
        cse.response = response;
        test.strictEqual(rem, remote);
        checkAttributes(test, attrs);
        local.dispatchEvent(cse);
        return 'check';
    });
}

function createCompletionCallback(test, expectedResult, expectedControllerState) {
    return function(actual, controllerState) {
        test.strictEqual(actual, expectedResult, 'expected success: ' + expectedResult);
        if (actual) {
            test.strictEqual(controllerState, expectedControllerState, 'expected to be controller: ' + expectedControllerState);
        }
        test.done();
    };
}

function setRemoteControllerState(test) {
    var attr = buildRemoteControllerAttribute();

    function found(type) {
        test.strictEqual(type, attr.type);
        return attr;
    }

    function notFound(type) {
        test.strictEqual(type, attr.type ^ 0x3); // switch 0x8029 for 0x802A, or vice-versa
        return null;
    }

    // if we are controller, then we expect the other to be controlled, and vice-versa
    if (remoteController === localController) {
        gently.expect(response, 'getStunAttribute', notFound);
    }
    gently.expect(response, 'getStunAttribute', found);
}

function checkSuccess(test, remoteOverride) {
    var now;
    var e = new Event('checksuccess');
    now = Date.now();
    e.request = {
        timestamp: new Date(now)
    };
    if (!remoteOverride) {
        setRemoteControllerState(test);
    }
    e.response = response;
    e.response.timestamp = new Date(now + 44);
    e.remote = remoteOverride || {
        ip: 'IP',
        port: 1337
    };
    local.dispatchEvent(e);
}

function expectClearTimeout(test) {
    gently.expect(timerManager, 'clearTimeout', function(h) {
        test.strictEqual(h, 'timeoutHandle');
    });
}

function expectCancelCheck(test) {
    gently.expect(local, 'cancelCheck', function(handle) {
        test.strictEqual(handle, 'check');
    });
}

function simpleTest(test, expectController) {
    function step2() {
        checkSuccess(test);
        expectClearTimeout(test);
    }

    function step1() {
        expectCheck(test, true);
        gently.expect(timerManager, 'setTimeout', function(f, t) {
            test.ok(80 <= t && t <= 120);
            // we aren't going to fire this one, instead go to step 2
            process.nextTick(step2);
            return 'timeoutHandle';
        });
        checker = new RealtimePortPairChecker(local, remote, localControlRandom, getOptions());
        checker.check(createCompletionCallback(test, true, expectController));
    }
    step1();
}

exports['check the checker success path'] = function(test) {
    localController = false;
    remoteController = true;
    simpleTest(test, false);
};

exports['the local machine can act as controller, no contention'] = function(test) {
    localController = true;
    remoteController = false;
    simpleTest(test, true);
};

exports['neither peer is controller, control goes to remote'] = function(test) {
    localController = false;
    remoteController = false;
    simpleTest(test, false);
};

exports['neither peer is controller, control goes to local'] = function(test) {
    localController = false;
    remoteController = false;
    tweakControlRandom(localControlRandom, 10); // very high - local controls
    simpleTest(test, true);
};

exports['contention for controller, control goes to remote'] = function(test) {
    localController = true;
    remoteController = true;
    simpleTest(test, false);
};

exports['contention for controller, control goes to local'] = function(test) {
    localController = true;
    remoteController = true;
    tweakControlRandom(localControlRandom, 10); // very high - local controls
    simpleTest(test, true);
};

exports['dead heat for controller'] = function(test) {
    localController = true;
    remoteController = true;
    tweakControlRandom(localControlRandom, 5);
    tweakControlRandom(remoteControlRandom, 5);
    simpleTest(test); // expect controller set to undefined
};

exports['checker supports the use of additional attributes'] = function(test) {
    localController = false;
    remoteController = true;
    extraAttribute = {
        type: 'whatever',
        value: 'don\'t care if this isn\'t an ArrayBuffer'
    };
    simpleTest(test, false);
};


function closeLocal() {
    local.dispatchEvent(new Event('close'));
}

exports['close event triggers failure'] = function(test) {
    expectCheck(test);
    gently.expect(timerManager, 'setTimeout', function(f, t) {
        process.nextTick(closeLocal);
        return 'timeoutHandle';
    });
    expectClearTimeout(test);
    expectCancelCheck(test);

    checker = new RealtimePortPairChecker(local, remote, localControlRandom, getOptions());
    checker.addEventListener('close', function() {
        // close event fires after reporting failure (failure is reported synchronously)
        test.done();
    });
    checker.check(function(success, controller) {
        test.strictEqual(success, false, 'should not have succeeded');
        test.strictEqual(controller, false, 'should not be controller');
    });
};

exports['filter out irrelevant check successes'] = function(test) {
    expectCheck(test);
    gently.expect(timerManager, 'setTimeout', function(f, t) {
        checkSuccess(test, {
            ip: 'foo',
            port: 1339
        });
        process.nextTick(closeLocal);
        return 'timeoutHandle';
    });
    expectClearTimeout(test);
    expectCancelCheck(test);
    checker = new RealtimePortPairChecker(local, remote, localControlRandom, getOptions());
    checker.check(createCompletionCallback(test, false));
};

exports['checks all fail'] = function(test) {
    var options = getOptions();
    var checkCount = options.maxChecks;
    var lastTimeout = 0;
    var i;

    local.addEventListener('checksent', function() {
        checkCount--;
    });

    function timeoutStub(f, t) {
        test.ok(t > lastTimeout);
        lastTimeout = t;
        process.nextTick(f);
        return 'timeoutHandle';
    }

    for (i = 0; i < options.maxChecks; ++i) {
        expectCheck(test);
        gently.expect(timerManager, 'setTimeout', timeoutStub);
    }
    expectCancelCheck(test);
    checker = new RealtimePortPairChecker(local, remote, localControlRandom, options);
    checker.check(createCompletionCallback(test, false));
};