'use strict';
var icejs = require('../lib/index');
var stubs = require('./curtcstub/index');
var RealtimePortGatherer = icejs.RealtimePortGatherer;
var Event = global.Event;
var EventTarget = global.EventTarget;
var Gently = require('gently');
var gently = new Gently();

function monkeyPatchRealtimePort(answer) {
    global.rtapi.RealtimePort.openLocalPorts = function(callback) {
        process.nextTick(function() {
            callback(!answer, answer);
        });
    };
}

exports['fail to produce ports'] = function(test) {
    var gatherer = new RealtimePortGatherer();
    monkeyPatchRealtimePort(null);

    gatherer.addEventListener('done', function(err, ports) {
        test.strictEqual(gatherer.ports.length, 0);
        test.done();
    });
    gatherer.gather();
};

exports['produce one port'] = function(test) {
    var port = new stubs.RealtimePort();
    var gatherer = new RealtimePortGatherer();
    monkeyPatchRealtimePort([port]);

    gatherer.addEventListener('port', function(e) {
        test.strictEqual(e.port, port);
    });

    gatherer.addEventListener('done', function() {
        test.strictEqual(gatherer.ports.length, 1);
        test.strictEqual(gatherer.ports[0], port);
        test.done();
    });
    gatherer.gather();
};

exports['close port and have it removed'] = function(test) {
    var port = new stubs.RealtimePort();
    var gatherer = new RealtimePortGatherer();
    monkeyPatchRealtimePort([port]);

    function check() {
        test.strictEqual(gatherer.ports.length, 0);
        test.done();
    }

    gatherer.addEventListener('done', function() {
        test.strictEqual(gatherer.ports.length, 1);
        port.emit('close');
        process.nextTick(check); // events take some time to get through
    });
    gatherer.gather();
};

function stunCheckTest(test, mappedSameAsBase) {
    var base = new stubs.RealtimePort();
    var baseFound = false;
    var reflexiveFound = false;
    var gatherer = new RealtimePortGatherer({
        stun: {
            ip: 'stun server'
        }
    });

    monkeyPatchRealtimePort([base]);

    function getMappedAddress() {
        if (mappedSameAsBase) {
            return {
                ip: base.ip,
                port: base.port
            };
        }
        return {
            ip: 'reflexive',
            port: 1339
        };
    }

    function fireCheckSuccess() {
        var e = new Event('checksuccess');
        e.response = {
            getMappedAddress: getMappedAddress
        };
        base.dispatchEvent(e);
    }

    gently.expect(base, 'check', function(r) {
        test.strictEqual(r.ip, 'stun server');
        test.strictEqual(r.port, 3478); // check insertion of default
        process.nextTick(fireCheckSuccess);
    });

    gatherer.addEventListener('port', function(e) {
        if (e.port === base) {
            baseFound = true;
        } else if (e.port.ip === 'reflexive') {
            reflexiveFound = true;
        } else {
            test.ok(false, 'unknown port');
        }
    });
    gatherer.addEventListener('done', function() {
        test.ok(baseFound);
        if (mappedSameAsBase) {
            test.strictEqual(gatherer.ports.length, 1, 'expected just one port');
            test.ok(!reflexiveFound, 'expected no reflexive address');
        } else {
            test.strictEqual(gatherer.ports.length, 2, 'expected two ports');
            test.ok(reflexiveFound, 'expected a reflexive address');
        }
        test.done();
    });
    gatherer.gather();
}


exports['STUN check a port'] = stunCheckTest;

exports['STUN check a port, but don\'t get a new reflexive address'] = function(test) {
    stunCheckTest(test, true);
};