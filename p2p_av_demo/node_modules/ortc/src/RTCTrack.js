/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 *   
 *   This code incorporates material from the Object RTC (ORTC) API for WebRTC community group specification draft
 *   dated 2013-11-03, obtained from http://www.w3.org/community/orca/.
 */

/*
 
 WebIDL
 [Constructor, Constructor(MediaStreamTrack)]
 interface RTCTrack {
                attribute MediaStreamTrack             source;
                attribute DOMString                    id;
                attribute DOMString                    kind;
                attribute unsigned long                ssrc;
                attribute sequence<RTCCodec>           codecs;
                attribute sequence<RTCMediaAttributes> mediaAttributes;
                attribute Object                       rtpExtHeaders;
   
    void start ();
    void stop ();
    void remove ();
};

*/


'use strict';

(function () {
    var g = ('undefined' !== typeof ortc) ? ortc : window;


    var self = null;
    var enabled = true;
    var audioCodecs = [];
    var videoCodecs = [];

    function RTCTrack(sourceMST) {
        self = this;

        if (!sourceMST || !(sourceMST instanceof g.MediaStreamTrack)) {
            throw new Error('Invalid MediaStreamTrack object');
        }

        var source = sourceMST;

        Object.defineProperty(this, 'source', {
            get: function () {
                return source;
            },
            set: function (value) {
                source = value;
            },
            enumerable: true
        });

        var id = '';

        Object.defineProperty(this, 'id', {
            get: function () {
                return id;
            },
            set: function (value) {
                id = value;
            },
            enumerable: true
        });

        var kind = sourceMST.kind;

        Object.defineProperty(this, 'kind', {
            get: function () {
                return kind;
            },
            set: function (value) {
                kind = value;
            },
            enumerable: true
        });

        var ssrc = sourceMST.ssrc;

        Object.defineProperty(this, 'ssrc', {
            get: function () {
                return ssrc;
            },
            set: function (value) {
                ssrc = value;
            },
            enumerable: true
        });

        var codecs = [];

        Object.defineProperty(this, 'codecs', {
            get: function () {
                return codecs;
            },
            set: function (value) {
                codecs = value;
            },
            enumerable: true
        });

        var mediaAttrs = [];

        Object.defineProperty(this, 'mediaAttributes', {
            get: function () {
                return mediaAttrs;
            },
            set: function (value) {
                mediaAttrs = value;
            },
            enumerable: true
        });

        var rtpExtHeaders = null;

        Object.defineProperty(this, 'rtpExtHeaders', {
            get: function () {
                return rtpExtHeaders;
            },
            set: function (value) {
                rtpExtHeaders = value;
            },
            enumerable: true
        });


        initialize();
    }


    //
    // Starts sending the track on the wire (if the RTCConnection is connected, or wait until it becomes connected).
    //
    RTCTrack.prototype.start = function () {

        if (this.id && this.source.transport) {

            var plugin = g.getPlugin();

            plugin.streamSetTransport(this.id, this.source.transport.id);
            plugin.streamPlay(this.id);
        }
        else {
            throw new Error('Failed to play track.');
        }
    }

    //
    // Stops sending the track on the wire.
    //
    RTCTrack.prototype.stop = function () {

        if (this.id) {
            var plugin = g.getPlugin();
            plugin.streamPause(this.id);
        }
    }

    //
    // Remove this sending track from the RTCConnection (automatically stops sending it on the wire). 
    //
    RTCTrack.prototype.remove = function () {

        if (this.id) {
            var plugin = g.getPlugin();
            plugin.streamClose(this.id);
            this.id = "";
        }
    }

    // get codec id for given type
    function getCodecId(mediaType) {
        var id = null;
        var codec = null;

        if (mediaType === 'audio') {
            codec = audioCodecs[0];
        }

        if (mediaType === 'video') {
            codec = videoCodecs[0];
        }

        if (codec) {
            codec.params.forEach(function (param) {
                if (param.name === 'codecId') {
                    id = param.value;
                }
            });
        }
        else {
            throw new Error('Codec not found');
        }

        return id;
    }

    // initialize track
    function initialize() {
        getSupportedCodecs();

        console.log('initializing track: ', self.ssrc);
        var plugin = g.getPlugin();

        var codecId = getCodecId(self.kind);

        if (self.id) {
            plugin.streamClose(self.id);
        }

        self.id = plugin.deviceNewStream(self.source.label, codecId, self.ssrc);
    }

    // get list of supported codecs
    function getSupportedCodecs() {

        self.codecs = g.util.getCodecs();

        audioCodecs = [];
        videoCodecs = [];

        self.codecs.forEach(function (codec) {
            codec.params.forEach(function (param) {
                if (param.name === 'mediaType' && param.value === 'audio') {
                    audioCodecs.push(codec);
                }

                if (param.name === 'mediaType' && param.value === 'video') {
                    videoCodecs.push(codec);
                }
            });
        });
    }


    g.RTCTrack = RTCTrack;

}());