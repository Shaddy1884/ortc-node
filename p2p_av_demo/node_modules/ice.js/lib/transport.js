/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 */


'use strict';

(function (g) {

    function createEnum(values) {
        var enumeration = {};
        var nameOfD = {};
        var names = [];

        values.forEach(function (value) {
            var name = value.toUpperCase().replace(/[^A-Z0-9_]/g, '_');

            Object.defineReadOnlyProperty(enumeration, name, value);

            nameOfD[value] = name;
            names.push(name);
        });

        Object.defineProperty(enumeration, 'nameOf', {
            value: function nameOf(e) {
                return nameOfD[e];
            }
        });

        Object.defineProperty(enumeration, 'values', {
            get: function () {
                return values.slice();
            }
        });

        Object.defineProperty(enumeration, 'names', {
            get: function () {
                return names.slice();
            }
        });

        return enumeration;
    }

    g.icejs.RealtimeTransportMode = createEnum(["srtp", "dtls-srtp", "rtp"]); // secret RTP mode

    function StunBinding(jsonString) {
        var obj = JSON.parse(jsonString); // yes, this will throw! let it
        var attributes = [];
        if (!obj.transactionId || !obj.attributes || !obj.timestamp) {
            throw new Error('missing parameters');
        }

        Object.defineReadOnlyProperty(this, 'transactionId', b64.Decode(obj.transactionId));
        attributes = obj.attributes.map(function (attr) {
            var attribute = {};
            Object.defineReadOnlyProperty(attribute, 'type', attr.type);
            if (attr.value) {
                Object.defineReadOnlyProperty(attribute, 'value', b64.Decode(attr.value));
            }
            return attribute;
        });

        Object.defineReadOnlyProperty(this, 'attributes', attributes);
        Object.defineReadOnlyProperty(this, 'timestamp', new Date(obj.timestamp));
    }

    g.icejs.StunBinding = StunBinding;

    StunBinding.ATTR_TYPE_MAPPED_ADDRESS = 0x0001;
    StunBinding.ATTR_TYPE_USERNAME = 0x0006;
    StunBinding.ATTR_TYPE_MESSAGE_INTEGRITY = 0x0008;
    StunBinding.ATTR_TYPE_ERROR_CODE = 0x0009;
    StunBinding.ATTR_TYPE_UNKNOWN_ATTRIBUTE = 0x000A;
    StunBinding.ATTR_TYPE_XOR_MAPPED_ADDRESS = 0x0020;
    StunBinding.ATTR_TYPE_FINGERPRINT = 0x8028;
    StunBinding.ATTR_TYPE_ICE_CONTROLLED = 0x8029;
    StunBinding.ATTR_TYPE_ICE_CONTROLLING = 0x802A;

    StunBinding.MAGIC_COOKIE = 0x2112A442;

    StunBinding.prototype.getStunAttribute = function (type) {
        return this.attributes.filter(function (attr) {
            return attr.type === type;
        })[0];
    };

    StunBinding.prototype.getMappedAddress = function () {
        var addrAttr = this.getStunAttribute(StunBinding.ATTR_TYPE_XOR_MAPPED_ADDRESS);
        var address = {};
        var addrView;
        var xor = StunBinding.MAGIC_COOKIE;
        if (!addrAttr) {
            addrAttr = this.getStunAttribute(StunBinding.ATTR_TYPE_MAPPED_ADDRESS);
            xor = 0;
            if (!addrAttr) {
                return null;
            }
        }
        addrView = new Uint8Array(addrAttr.value);

        var xor0 = (xor >> 24) & 0xff;
        var xor1 = (xor >> 16) & 0xff;
        var xor2 = (xor >> 8) & 0xff;
        var xor3 = (xor >> 0) & 0xff;

        address.port = ((addrView[2] ^ xor0) << 8) | (addrView[3] ^ xor1);
        address.ip = "" + (addrView[4] ^ xor0);
        address.ip += "." + (addrView[5] ^ xor1);
        address.ip += "." + (addrView[6] ^ xor2);
        address.ip += "." + (addrView[7] ^ xor3);
        return address;
    };

    function initialize(port) {
        // setup the plugin
        var plugin = g.ortc.getPlugin();

        // setup a wrapper event handler from the plugin -> javascript
        // this wrapper determines the proper event parameters and 
        // triggers the event.

        function eventHandler(eventType, rem, handle, request, response) {
            var event;
            var obj;
            if (!port.open && eventType !== 'close') {
                return;
            }

            // was the check cancelled?
            if (eventType in {
                'checksent': '',
                'checksuccess': ''
            }) {
                if (port.cancelledChecks[handle] === true) {
                    return;
                }
            }

            // initialize an event object
            event = new Event(eventType);

            if (rem !== "") {
                event.remote = JSON.parse(rem);
            }

            // get the request/response 
            if (eventType === 'checksuccess' || eventType === 'remotecheck') {
                event.request = new g.icejs.StunBinding(request);
                event.response = new g.icejs.StunBinding(response);
            }

            port.dispatchEvent(event);
        }

        // setup the plugin wrapper handlers
        ['checksent', 'checksuccess', 'close', 'networkchange', 'remotecheck'].forEach(function (evt) {
            port.defineEventProperty(evt);
            plugin.candidateRegisterEvent(port.id, 'on' + evt, function (rem, handle, request, response) {
                console.log(port.id, evt, rem, handle, request, response);
                eventHandler(evt, rem, handle, request, response);
            });
        });
    }

    function RealtimePort(id, ip, port, ufrag, pwd) {
        RealtimePort.super_.call(this);
        // connectivity information
        Object.defineProperty(this, 'id', {
            value: id
        });
        Object.defineProperty(this, 'cancelledChecks', {
            value: {}
        });

        Object.defineReadOnlyProperty(this, 'ip', ip);
        Object.defineReadOnlyProperty(this, 'port', port);
        Object.defineReadOnlyProperty(this, 'pwd', pwd);
        Object.defineReadOnlyProperty(this, 'ufrag', ufrag);
        Object.defineReadOnlyProperty(this, 'open', true);
        Object.defineReadOnlyProperty(this, 'serverAttributes', []);

        initialize(this);
    }

    Object.inherits(RealtimePort, EventTarget);

    g.icejs.RealtimePort = RealtimePort;


    RealtimePort.prototype.allocateRelay = function (turnServer, relayCallback) {
        throw new Error("unsupported: allocateRelay");
    };

    RealtimePort.prototype.cancelCheck = function (checkHandle) {
        if (this.open === false) {
            return; // automatic success!
        }

        this.cancelledChecks[checkHandle] = true;

        var plugin = g.ortc.getPlugin();
        return plugin.candidateCancelCheck(this.id, checkHandle);
    };

    RealtimePort.prototype.check = function (remotePort, attributes) {
        if (this.open === false) {
            throw new Error("port is not open");
        }

        if ((typeof remotePort !== 'object') || (typeof remotePort.ip !== 'string') || (typeof remotePort.port !== 'number')) {
            throw new Error("check: invalid parameter");
        }

        // XXX - check for existing check on the same port
        var plugin = g.ortc.getPlugin();

        // if we don't know about it, add the remote port to the plugin
        var remoteId = g.ortc.util.getRemotePortId(remotePort, true);

        attributes = attributes || [];
        var strAttr = JSON.stringify(attributes.map(encodeAttribute));
        var checkId = plugin.candidateCheck(this.id, remoteId, function () { }, strAttr);

        if (checkId <= 0) {
            // we have an invalid handle
            throw new Error("check: too many checks queued");
        }

        return checkId;
    };

    RealtimePort.prototype.close = function () {
        var plugin;
        if (this.open) {
            Object.defineReadOnlyProperty(this, 'open', false);
            plugin = g.ortc.getPlugin();
            plugin.candidateClose(this.id);
            this.dispatchEvent(new Event('close'));
        }
    };

    RealtimePort.prototype.status = function (remotePort) {
        if (this.open === false) {
            throw new Error("port is not open");
        }
        var remotePortId = g.ortc.util.getRemotePortId(remotePort, false);
        if (typeof remotePortId !== 'string') {
            return false;
        }
        var plugin = g.ortc.getPlugin();
        var result = plugin.checkCandidatePairStatus(this.id, remotePortId);
        return result;
    };

    function encodeAttribute(attr) {
        if (attr.value) {
            return {
                type: attr.type,
                value: b64.Encode(attr.value)
            };
        }
        return attr;
    }

    RealtimePort.prototype.setServerAttributes = function (attributes) {
        var strValue = JSON.stringify(attributes.map(encodeAttribute));
        var result = g.ortc.getPlugin().candidateSetServerAttributes(this.id, strValue);
        if (result) {
            Object.defineReadOnlyProperty(this, 'serverAttributes', attributes);
        }
        return result;
    };

    RealtimePort.prototype.getCounter = function (counter) {
        return g.ortc.util.getCounter('candidate', this, counter);
    };

    RealtimePort.prototype.getCounters = function () {
        return g.ortc.util.getCounters('candidate', this);
    };

    RealtimePort.openLocalPorts = function (realtimePortCallback) {
        if (realtimePortCallback === null || typeof realtimePortCallback === 'undefined') {
            throw new Error("openLocalPorts: invalid parameters");
        }

        var plugin = g.ortc.getPlugin();

        // call the plugin to gather the hosts
        plugin.gatherHostCandidates(

        function (candidatesJson) {
            var r = [];
            var cands = JSON.parse(candidatesJson);
            for (var i = 0; i < cands.length; i++) {
                var cand = cands[i];
                var ip = cand.ip;
                var port = parseInt(cand.port, 10);
                var ipPort = ip + ':' + port;
                var rto = new RealtimePort(cand.candidateId, ip, port, cand.ufrag, cand.pwd);
                r[r.length] = rto;
            }
            realtimePortCallback(null, r);
        }, function () { });
    };

    RealtimePort.allocateRelay = function (turnServer, realtimePortCallback) {
        throw new Error("unsupported: allocateRelay");
    };


    var RealtimeTransportMode = g.icejs.RealtimeTransportMode;

    function copyRemotePort(remotePort) {
        var fields = ['ip', 'port', 'ufrag', 'pwd'];
        var copy = {};

        fields.forEach(function (field) {
            if (remotePort && remotePort.hasOwnProperty(field)) {
                copy[field] = remotePort[field];
            }
        });
        return copy;
    }

    function ipToInt32(ip) {
        var intVal = 0;
        var i;
        var piece = 0;
        for (i = 0; i < ip.length; ++i) {
            if (ip.charAt(i) === '.') {
                intVal += piece;
                piece = 0;
                intVal = (intVal * 256);
            } else {
                piece = (piece * 10) + parseInt(ip.charAt(i), 10);
            }
        }
        intVal += piece;
        return intVal;
    }

    function transportSig(lp, rp) {
        var sig = ipToInt32(lp.ip) + ':' + lp.port;
        sig += '/';
        sig += ipToInt32(rp.ip) + ':' + rp.port;
        return sig;
    }

    var transportSigs = {};

    function startChecking(transport) {
        var timerId;

        function check() {
            try {
                transport.localPort.check(transport.remotePort);
            } catch (e) {
                clearInterval(timerId);
            }
        }
        timerId = setInterval(check, 2999);
        transport.addEventListener('close', function () {
            clearInterval(timerId);
        });
        if (!transport.consent) {
            check();
        }
    }

    function RealtimeTransport(id, localPort, remotePort) {
        var remotePortCopy = copyRemotePort(remotePort);
        var self = this;
        var plugin = g.ortc.getPlugin();

        RealtimeTransport.super_.call(this);
        Object.defineProperty(this, 'id', {
            value: id
        });

        Object.defineReadOnlyProperty(this, 'localPort', localPort);
        Object.defineReadOnlyProperty(this, 'remotePort', remotePortCopy);
        Object.defineReadOnlyProperty(this, 'dtls');
        Object.defineReadOnlyProperty(this, 'remoteCertificate');
        Object.defineReadOnlyProperty(this, 'outboundSdes');
        Object.defineReadOnlyProperty(this, 'inboundSdes');
        Object.defineReadOnlyProperty(this, 'open', true);
        Object.defineReadOnlyProperty(this, 'bandwidth');
        Object.defineReadOnlyProperty(this, 'consent', localPort.status(remotePortCopy));

        ['consent', 'consentexpired', 'bandwidthchange', 'unknownssrc'].forEach(function (eventType) {
            self.defineEventProperty(eventType);
            plugin.transportRegisterEvent(self.id, eventType, function (data) {
                var i;
                var ev = new Event(eventType);
                console.log(self.id, eventType, data);
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    // ignore
                }
                for (i in data) {
                    if (data.hasOwnProperty(i)) {
                        ev[i] = data[i];
                    }
                }
                self.dispatchEvent(ev);
            });
        });

        localPort.addEventListener('close', this.close.bind(this));
        self.defineEventProperty('close');
        plugin.transportRegisterEvent(self.id, 'close', this.close.bind(this));
    }

    Object.inherits(RealtimeTransport, EventTarget);
    g.icejs.RealtimeTransport = RealtimeTransport;

    var SDES_DEFAULTS = {
        'encrypt': 'AES-CM',
        'encryptRtp': true,
        'encryptRtcp': true,
        'keystreamPrefix': 0,
        'authenticate': 'HMAC-SHA1',
        'n_a': 160,
        'n_tag': 80,
        'keyDerivation': 'AES-CM',
        'keyDerivationInterval': 0
    };

    function copyArrayBuffer(buf) {
        var copy = new ArrayBuffer(buf.byteLength);
        var copyView = new Uint8Array(copy);
        var bufView = new Uint8Array(buf);
        var i;
        for (i = 0; i < copyView.length; ++i) {
            copyView[i] = bufView[i];
        }
        return copy;
    }

    function checkSdes(sdes) {
        var copy = {};
        var i;
        for (i in SDES_DEFAULTS) {
            if (SDES_DEFAULTS.hasOwnProperty(i)) {
                if (sdes[i] && sdes[i] !== SDES_DEFAULTS[i]) {
                    throw new Error('unsupported mode for ' + i + ', only ' + SDES_DEFAULTS[i] + ' supported');
                }
                copy[i] = SDES_DEFAULTS[i];
            }
        }
        if (!sdes.key || sdes.key.byteLength !== 16) {
            throw new Error('invalid SDES key');
        }
        copy.key = copyArrayBuffer(sdes.key);
        if (!sdes.salt || sdes.salt.byteLength !== 14) {
            throw new Error('invalid SDES salt');
        }
        copy.salt = copyArrayBuffer(sdes.salt);
        return copy;
    }

    function prepareSdesForStringify(sdes) {
        if (!sdes) {
            return; // undefined
        }
        return {
            key: b64.Encode(sdes.key),
            salt: b64.Encode(sdes.salt)
        };
    }

    RealtimeTransport.createTransport = function createTransport(localPort, remotePort, options, callback) {
        var inboundSdes, outboundSdes;

        var sig = transportSig(localPort, remotePort);
        if (transportSigs[sig]) {
            throw new Error('duplicate transport ' + sig);
        }

        if (!options) {
            throw new Error('missing options');
        }
        if (!options.mode) {
            throw new Error('missing options.mode (rtp or srtp)');
        }
        if (typeof callback !== 'function') {
            throw new Error('invalid callback');
        }

        if (options.mode === RealtimeTransportMode.SRTP) {
            inboundSdes = checkSdes(options.inboundSdes);
            outboundSdes = checkSdes(options.outboundSdes);
        } else if (options.mode !== RealtimeTransportMode.RTP) {
            throw new Error('unsupported transport mode');
        }

        transportSigs[sig] = 1;

        var plugin = g.ortc.getPlugin();

        var localId = localPort.id;
        var remoteId = g.ortc.util.getRemotePortId(remotePort, true);

        function transportCreated(err, transportId) {
            var transport;
            if (err === '') {
                transport = new RealtimeTransport(transportId, localPort, remotePort);
                Object.defineReadOnlyProperty(transport, 'inboundSdes', inboundSdes);
                Object.defineReadOnlyProperty(transport, 'outboundSdes', outboundSdes);
                startChecking(transport);
                err = null;
            }
            callback(err, transport); // rely on '' being falsy
            delete transportSigs[sig];
        }

        var stringOptions = JSON.stringify({
            mode: options.mode,
            inboundSdes: prepareSdesForStringify(inboundSdes),
            outboundSdes: prepareSdesForStringify(outboundSdes)
        });

        plugin.candidateCreateTransport(localId, remoteId, transportCreated, stringOptions);
    };

    RealtimeTransport.prototype.close = function close() {
        var plugin;

        if (this.open) {
            var sig = transportSig(this.localPort, this.remotePort);
            delete transportSigs[sig];

            Object.defineReadOnlyProperty(this, 'open', false);

            plugin = g.ortc.getPlugin();
            plugin.transportClose(this.id);

            this.dispatchEvent(new Event('close'));
        }
    };

    RealtimeTransport.prototype.getCounter = function (counter) {
        return g.ortc.util.getCounter('transport', this, counter);
    };

    RealtimeTransport.prototype.getCounters = function () {
        return g.ortc.util.getCounters('transport', this);
    };

}((typeof window === 'object') ? window : global));
