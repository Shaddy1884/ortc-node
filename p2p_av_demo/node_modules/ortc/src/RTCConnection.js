/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 *   
 *   This code incorporates material from the Object RTC (ORTC) API for WebRTC community group specification draft
 *   dated 2013-11-03, obtained from http://www.w3.org/community/orca/.
 */

/*

 WEBIDL

[Constructor (RTCConnectionOptions options)]
interface RTCConnection : EventTarget  {
    attribute {{RTCConnectionSide}}     local;
    attribute {{RTCConnectionSide}}     remote;

    RTCSocket                           getLocalSocket ();
    void                                setLocalCandidate ();
    void                                setRemoteCandidate ();
    void                                connect ();
    void                                update ();
    void                                addStream ();
    void                                removeStream ();
    RTCTrack                            track ();
    sequence<RTCTrack>                  tracks ();
    void                                receiveTrack ();
    RTCDTMFHandler                      addDtmfHandler ();
    sequence<MediaStream>               getSendingStreams ();
    sequence<MediaStream>               getReceivingStreams ();
    void                                close ();
   
   attribute EventHandler                  oncandidate;
   attribute EventHandler                  onendofcandidates;
   attribute EventHandler                  onactivecandidate;
   attribute EventHandler                  onconnected;
   attribute EventHandler                  ondisconnected;
   attribute EventHandler                  onaddstream;
   attribute EventHandler                  onunknowntrack;
   attribute EventHandler                  onadddtmfhandler;
};

*/


'use strict';

(function () {

    var g = ('undefined' !== typeof ortc) ? ortc : window;


    var self = null;
    var socket = null;
    var options = null;
    var transport = null;
    var transportBuilder = null;

    var tracks = [];
    var localTracks = [];
    var remoteTracks = [];
    var localStreams = [];
    var remoteStreams = [];
    var localCandidates = [];
    var remoteCandidates = [];


    function RTCConnection(opts) {
        EventTarget.call(this);

        self = this;
        options = opts;


        var local = new g.RTCConnectionSide();
        var remote = new g.RTCConnectionSide();


        Object.defineProperty(this, 'local', {
            get: function () {
                return local;
            },
            set: function (value) {
                local = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'remote', {
            get: function () {
                return remote;
            },
            set: function (value) {
                remote = value;
            },
            enumerable: true
        });


        this.defineEventProperty('candidate');
        this.defineEventProperty('endofcandidates');
        this.defineEventProperty('activecandidate');
        this.defineEventProperty('connected');
        this.defineEventProperty('disconnected');
        this.defineEventProperty('addstream');
        this.defineEventProperty('unknowntrack');
        this.defineEventProperty('adddtmfhandler');

        generateConfig();
        startICEGathering();
        socket = new g.RTCSocket();
    }

    Object.inherits(RTCConnection, EventTarget);

    //
    // get RTCSocket associated with this connection 
    //
    RTCConnection.prototype.getLocalSocket = function () {
        return socket;
    };

    //
    // set local ICE candidate
    //
    RTCConnection.prototype.setLocalCandidate = function (candidate) {
        localCandidates.push(candidate);
    };

    //
    // set remote ICE candidate
    //
    RTCConnection.prototype.setRemoteCandidate = function (candidate) {

        remoteCandidates.push(candidate);

        if (transportBuilder) {
            transportBuilder.addRemote({
                ip: candidate.connectionAddress,
                port: candidate.connectionPort,
                ufrag: candidate.foundation,
                pwd: candidate.priority
            });
        }
    };

    //
    // connect to remote peer
    //
    RTCConnection.prototype.connect = function () {

        if (!this.remote || !this.remote.ice.usernameFrag || !this.remote.ice.password) {
            throw new Error('Connection data for the remote side missing.');
        }

        establishConnection();
    };

    //
    // update connection due to network changes
    //
    RTCConnection.prototype.update = function () {
        this.close();
        startICEGathering();
    };

    //
    // add stream to send queue
    //
    RTCConnection.prototype.addStream = function (msStream, auto) {

        localStreams.push(msStream);

        if (msStream.audioTracks) {
            for (var i = 0; i < msStream.audioTracks.length; ++i) {
                var mssTrack = msStream.audioTracks.item(i);
                var rtcTrack = new g.RTCTrack(mssTrack, mssTrack.kind, generateSSRC(), [msStream.id], transport);
                localTracks.push(rtcTrack);
            }
        }

        if (msStream.videoTracks) {
            for (var i = 0; i < msStream.videoTracks.length; ++i) {
                var mssTrack = msStream.videoTracks.item(i);
                var rtcTrack = new g.RTCTrack(mssTrack, mssTrack.kind, generateSSRC(), [msStream.id], transport);
                localTracks.push(rtcTrack);
            }
        }
    };

    //
    // remove stream from send queue
    //
    RTCConnection.prototype.removeStream = function (msStream) {

        // check if requested stream exists
        // find all tracks linked to this stream
        // stop all those tracks
        // remove msid from those tracks
        // if msid empty remove track also
        // finally remove stream

        // TODO
        // what if that track belongs to multiple streams ? (i.e. msid has more entries besides msStream.id) 
        // in that case too should the track be stopped ?

        for (var i = remoteStreams.length - 1; i >= 0; i--) {
            if (msStream.id === remoteStreams[i].id) {
                for (var j = remoteTracks.length - 1; j >= 0; j--) {
                    var ind = remoteTracks[j].msid.indexOf(msStream.id);

                    if (ind > -1) {
                        remoteTracks[j].stop();
                        remoteTracks[j].msid.splice(ind, 1);

                        if (remoteTracks[j].msid.length === 0) {
                            remoteTracks.splice(j, 1);
                        }

                        remoteStreams.splice(i, 1);
                    }
                }
            }
        }
    };

    //
    // get RTCTrack for given MediaStreamTrack
    //
    RTCConnection.prototype.track = function (mssTrack) {

        var retTrack = null;

        localTracks.forEach(function (track) {
            if (track.source.id === mssTrack.id) {
                retTrack = track;
            }
        });

        return retTrack;
    };

    //
    // get RTCTrack/s based on filter
    //
    RTCConnection.prototype.tracks = function (filter) {
        var tracks = [];

        localTracks.forEach(function (track) {

            if (filter) {
                if ((filter.stream && track.msid.indexOf(filter.stream.id) > -1) ||
                    (filter.kind && filter.kind === track.kind)) {
                    tracks.push(track);
                }
            }
            else {
                tracks.push(track);
            }
        });

        return tracks;
    };

    //
    //  add track info to recieve remote stream
    //
    RTCConnection.prototype.receiveTrack = function (description) {

        var deviceId;

        if (description.kind === 'video') {
            deviceId = g.util.getDevice(false, false);
        }
        else {
            deviceId = g.util.getDevice(true, false);
        }

        var msStream = getRemoteStream(description.msid);

        if (deviceId && deviceId != "-1") {
            var mssTrack = new g.MediaStreamTrack(deviceId);
            var rtcTrack = new g.RTCTrack(mssTrack, mssTrack.kind, description.ssrc, description.msid, transport);
            rtcTrack.codecs = description.codecs;
            rtcTrack.mediaAttributes = description.mediaAttributes;
            rtcTrack.rtpExtHeaders = description.rtpExtHeaders;

            msStream.addTrack(mssTrack);
            remoteTracks.push(rtcTrack);
        }

        dispatchEvent('addstream', msStream);
    };

    //
    // add DTMFHandler to the connection
    //
    RTCConnection.prototype.addDtmfHandler = function (msStream) {

        var handler = new g.RTCDTMFHandler();
        dispatchEvent('adddtmfhandler', handler);
    };

    //
    // get streams in sending queue
    //
    RTCConnection.prototype.getSendingStreams = function () {
        return localStreams;
    };

    //
    // get streams in recieving queue
    //
    RTCConnection.prototype.getReceivingStreams = function () {
        return remoteStreams;
    };

    //
    // close this RTCConnection
    //
    RTCConnection.prototype.close = function () {

        localTracks.forEach(function (track) {
            track.stop();
        });

        remoteTracks.forEach(function (track) {
            track.stop();
        });

        if (transportBuilder) {
            transportBuilder.stop();
        }

        dispatchEvent('disconnected');
    };


    function dispatchEvent(type, value) {
        var evt = new Event(type);

        switch (type) {

            case 'candidate':
                evt.candidate = value;
                break;

            case 'activecandidate':
                evt.localCandidate = value.local;
                evt.remoteCandidate = value.remote;
                break;

            case 'addstream':
                evt.stream = value;
                break;

            case 'unknowntrack':
                evt.rtpExtHeaders = value;
                break;

            case 'adddtmfhandler':
                evt.handler = value;
                break;
        }

        self.dispatchEvent(evt);
    }

    function getRemoteStream(msid) {
        var msStream = null;

        remoteStreams.forEach(function (stream) {
            msid.forEach(function (id) {
                if (stream.id === id) {
                    msStream = stream;
                }
            });
        });

        if (!msStream) {
            msStream = new g.MediaStream(msid[0]);
            remoteStreams.push(msStream);
        }

        return msStream;
    }

    function generateConfig() {

        self.local.ice = new g.RTCIceConnectionInfo(gatewayClient.localConfig.port.ufrag, gatewayClient.localConfig.port.pwd);
        self.remote.ice = new g.RTCIceConnectionInfo();
    }

    function startICEGathering() {
        var trOptions = {
            transport: {
                mode: 'srtp',
                outboundSdes: gatewayClient.localConfig.sdes,
                inboundSdes: gatewayClient.remoteConfig.sdes
            },
            stun: {
                ip: options.iceServers[0].url.split(':')[1],    //'168.61.2.180',
                port: Number(options.iceServers[0].url.split(':')[2])   //8888
            }
        };

        transportBuilder = new RealtimeTransportBuilder(trOptions);
        transportBuilder.addEventListener('connect', gotConnection);
        transportBuilder.addEventListener('port', gotPort);
        transportBuilder.addEventListener('error', gotConnectionError);
        transportBuilder.start();
    }

    function generateSSRC() {
        return Math.abs(Math.random() * Math.pow(2, 32) | 0);
    }

    function establishConnection() {

        if (transport && localTracks.length > 0 && remoteTracks.length > 0) {

            localTracks.forEach(function (track) {
                if (!track.transport) {
                    track.transport = transport;
                }

                track.start();
            });

            remoteTracks.forEach(function (track) {
                if (!track.transport) {
                    track.transport = transport;
                }

                track.start();
            });
        }
    }

    function remoteTrackReady(e) {

        var unc = true;

        remoteTracks.forEach(function (track) {
            if (track.ssrc === e.ssrc) {
                unc = false;
            }
        });

        localTracks.forEach(function (track) {
            if (track.ssrc === e.ssrc) {
                unc = false;
            }
        });

        establishConnection();

        if (unc) {
            dispatchEvent('unknowntrack', e.ssrc);
        }
    }

    function gotConnection(e) {
        console.log('got transport');

        dispatchEvent('endofcandidates');

        transport = e.transport;
        transport.addEventListener('unknownssrc', remoteTrackReady);

        var localCand = new g.RTCIceCandidateDescription(e.local.ufrag, '', 'udp', e.local.pwd, e.local.ip, e.local.port, e.local.type, '', '');
        var remoteCand = new g.RTCIceCandidateDescription(e.remote.ufrag, '', 'udp', e.remote.pwd, e.remote.ip, e.remote.port, e.remote.type, '', '');
        dispatchEvent('activecandidate', { local: localCand, remote: remoteCand });

        establishConnection();

        dispatchEvent('connected');
    }

    function gotConnectionError(e) {
        console.log('got transport error');

        // onerror more appropriate.
        dispatchEvent('disconnected');
    }

    function gotPort(e) {
        console.log('got port');

        var cand = new g.RTCIceCandidateDescription(e.port.ufrag, '', 'udp', e.port.pwd, e.port.ip, e.port.port, e.port.type, '', '');
        dispatchEvent('candidate', cand);
    }


    g.RTCConnection = RTCConnection;

}());
