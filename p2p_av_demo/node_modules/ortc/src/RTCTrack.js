/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 *   
 *   This code incorporates material from the Object RTC (ORTC) API for WebRTC community group specification draft
 *   dated 2013-11-03, obtained from http://www.w3.org/community/orca/.
 */

/*
 
 WEBIDL
 
 interface RTCTrack  {
    readonly    attribute {{MediaStreamTrack}}                source;
    readonly    attribute DOMString                           kind;
    readonly    attribute DOMString                           ssrc;
    attribute sequence<DOMString>                 msid;
    attribute sequence<RTCCodec>                  codecs;
    attribute sequence<RTCMediaAttributes>        mediaAttributes;
    attribute Object                              rtpExtHeaders;

    RTCTrackDescription                 getDescription ();
    void                                start ();
    void                                stop ();
    void                                remove ();
 };

*/


'use strict';

(function () {
    var g = ('undefined' !== typeof ortc) ? ortc : window;


    var self = null;
    var audioCodecs = [];
    var videoCodecs = [];

    function RTCTrack(source, kind, ssrc, msid, transport) {
        self = this;

        var msIds = [];
        var codecs = [];
        var enabled = true;
        var transport = null;
        var mediaAttrs = [];
        var rtpExtHeaders = null;

        Object.defineReadOnlyProperty(this, 'source', source);
        Object.defineReadOnlyProperty(this, 'kind', kind);
        Object.defineReadOnlyProperty(this, 'ssrc', ssrc);


        Object.defineProperty(this, 'msid', {
            get: function () {
                return msIds;
            },
            set: function (value) {
                msIds = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'codecs', {
            get: function () {
                return codecs;
            },
            set: function (value) {
                codecs = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'mediaAttributes', {
            get: function () {
                return mediaAttrs;
            },
            set: function (value) {
                mediaAttrs = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'rtpExtHeaders', {
            get: function () {
                return rtpExtHeaders;
            },
            set: function (value) {
                rtpExtHeaders = value;
            },
            enumerable: true
        });

        Object.defineProperty(this, 'enable', {
            get: function () {
                return enabled;
            },
            set: function (value) {
                enabled = value;
            },
            enumerable: true
        });


        if (transport) {
            Object.defineProperty(this, 'transport', {
                get: function () {
                    return transport;
                },
                set: function (value) {
                    transport = value;
                },
                enumerable: true
            });
        }

        msIds = msid;
        initialize();
    }

    //
    // Get RTCTrackDescription for this track.
    //
    RTCTrack.prototype.getDescription = function () {
        return new g.RTCTrackDescription(this.kind, this.ssrc, this.msid, this.codecs, this.mediaAttributes, this.rtpExtHeaders);
    }

    //
    // Starts sending the track on the wire (if the RTCConnection is connected, or wait until it becomes connected).
    //
    RTCTrack.prototype.start = function () {

        if (this.transport) {

            var plugin = g.getPlugin();

            if (!this.enable) {
                initialize();
            }

            plugin.streamSetTransport(this.id, this.transport.id);
            plugin.streamPlay(this.id);
        }
        else {
            throw new Error('Failed to play track.');
        }
    }

    //
    // Stops sending the track on the wire.
    //
    RTCTrack.prototype.stop = function () {

        if (this.id) {
            var plugin = g.getPlugin();
            plugin.streamClose(this.id);
        }
    }

    //
    // Remove this sending track from the RTCConnection (automatically stops sending it on the wire). 
    //
    RTCTrack.prototype.remove = function () {

        this.stop();
        this.enabled = false;
    }


    function getCodecId(mediaType) {
        var id = null;
        var codec = null;

        if (mediaType === 'audio') {
            codec = audioCodecs[0];
        }

        if (mediaType === 'video') {
            codec = videoCodecs[0];
        }

        if (codec) {
            codec.params.forEach(function (param) {
                if (param.name === 'codecId') {
                    id = param.value;
                }
            });
        }
        else {
            throw new Error('Codec not found');
        }

        return id;
    }

    function initialize() {
        getSupportedCodecs();

        console.log('initializing track: ', self.ssrc);
        var plugin = g.getPlugin();

        var codecId = getCodecId(self.kind);

        if (self.id) {
            plugin.streamClose(self.id);
        }

        var id = plugin.deviceNewStream(self.source.label, codecId, self.ssrc);

        Object.defineReadOnlyProperty(self, 'id', id);
    }

    function getSupportedCodecs() {

        self.codecs = g.util.getCodecs();

        audioCodecs = [];
        videoCodecs = [];

        self.codecs.forEach(function (codec) {
            codec.params.forEach(function (param) {
                if (param.name === 'mediaType' && param.value === 'audio') {
                    audioCodecs.push(codec);
                }

                if (param.name === 'mediaType' && param.value === 'video') {
                    videoCodecs.push(codec);
                }
            });
        });
    }


    g.RTCTrack = RTCTrack;

}());