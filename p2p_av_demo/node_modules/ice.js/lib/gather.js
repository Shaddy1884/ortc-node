/*
 *   Copyright © Microsoft Open Technologies, Inc.
 *   All Rights Reserved        
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 *   the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *   THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 *   INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *   MERCHANTABLITY OR NON-INFRINGEMENT. 
 *   
 *   See the Apache 2 License for the specific language governing permissions and limitations under the License.
 */
/*
[Constructor(RealtimeTransportBuilderOptions options)]
interface RealtimePortGatherer : EventTarget {
    void gather();
    EventHandler? onport;
    EventHandler? notmultihomed;
};

// ondone is fired when all the local and server reflexive ports are collected
// onport is fired before ondone for local and server reflexive
// on

dictionary IceRealtimePortGathererOptions {
    StunServer stun;
};

dictionary StunServer : RemoteRealtimePort {
    unsigned short port = 3478;  
};
 */

(function (g) {
    'use strict'; /*jshint browser:true,node:true*/

    var RealtimePort = g.icejs.RealtimePort;
    var RealtimePortEvent = g.icejs.RealtimePortEvent;
    var ReflexiveRealtimePort = g.icejs.ReflexiveRealtimePort;

    function groomOptions(options) {
        var opts = options || {};
        if (opts.stun) {
            opts.stun.port = opts.stun.port || 3478;
        }
        opts.timeout = opts.timeout || 3000;
        return opts;
    }

    function closeAnything(resource) {
        resource.close();
    }

    function RealtimePortGatherer(options, timerManager) {
        var self = this;
        var ports = [];
        var outstanding = 0;
        var timeout = null;

        g.EventTarget.call(this);
        options = groomOptions(options);
        timerManager = timerManager || g;

        function stepDone() {
            --outstanding;
            if (outstanding <= 0) {
                self.dispatchEvent(new g.Event('done'));
                timerManager.clearTimeout(timeout);
                timeout = null;
            }
        }

        function giveUp() {
            outstanding = 0;
            stepDone();
        }

        function stepTriggered() {
            if (timeout === null) {
                timeout = timerManager.setTimeout(giveUp, options.timeout);
            }
            ++outstanding;
        }


        function portClosed(event) {
            var i = ports.indexOf(event.target);
            if (i >= 0) {
                ports.splice(i, 1);
            }
        }

        function newRealtimePort(type, port) {
            port.type = type; // we may use this to prioritize, eventually
            port.addEventListener('close', portClosed);
            ports.push(port);
            self.dispatchEvent(new RealtimePortEvent(port));
        }

        function duplicateAddress(address, base) {
            return ports.some(function (port) {
                var cbase = port.base || port;
                return (base.ip === cbase.ip && base.port === cbase.port) && //
                (port.ip === address.ip && port.port === address.port);
            });
        }

        function newReflexiveRealtimePort(ev) {
            var rflx;
            // the event contains a StunBinding response, which should contain an IP and port
            var address = ev.response.getMappedAddress();
            var base = ev.target;
            if (address && !duplicateAddress(address, base)) {
                rflx = new ReflexiveRealtimePort(base, address.ip, address.port);
                newRealtimePort('reflexive', rflx); // yes we don't distinguish between server and peer reflexive!
            }
            stepDone();
        }

        function newHostRealtimePort(port) {
            newRealtimePort('host', port);
            if (options.stun) {
                port.addEventListener('checksuccess', newReflexiveRealtimePort);
                stepTriggered();
                port.check(options.stun);
            }
        }

        function hostPortsOpen(err, opened) {
            if (!err) {
                if (opened.length < 2) {
                    self.dispatchEvent(new g.Event('notmultihomed'));
                }

                opened.forEach(newHostRealtimePort);
            }
            stepDone();
        }

        this.gather = function () {
            stepTriggered();
            RealtimePort.openLocalPorts(hostPortsOpen);
        };

        this.closeAll = function () {
            ports.forEach(closeAnything);
        };

        Object.defineProperty(self, 'ports', {
            get: function () {
                return ports.concat();
            },
            enumerable: true
        });

        this.defineEventProperty('port');
        this.defineEventProperty('notmultihomed');
    }

    Object.inherits(RealtimePortGatherer, g.EventTarget);


    g.icejs.RealtimePortGatherer = RealtimePortGatherer;

}((typeof window === 'object') ? window : global));
